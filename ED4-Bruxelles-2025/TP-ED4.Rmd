---
title: "Place à la pratique ! Premiers pas sur R"
author: "Anaïs Vignoles"
date: "2025-09-17"
output: 
  html_document:
    toc: yes
    theme: sandstone
    highlight: zenburn
editor_options: 
  markdown: 
    wrap: 72
---

## 1- Introduction

Dans cette introduction, nous allons découvrir les bases du langage de
programmation R. 

Tout d'abord, tout le texte précédé par un **\#** est ce qu'on appelle
un **commentaire**. 

```{r comment}

# commentaire

```

Ce sont des lignes qui ne seront pas exécutées par le code et qui nous
permettront de décrire les étapes du script. Bien commenter son code est
très important car cela nous permet de le comprendre facilement même
après des mois et des années sans y avoir travaillé (en théorie !). Cela
nous permet aussi de le partager avec d'autres personnes, pour qu'elles
comprennent tout de suite notre démarche. 

Nous allons travailler ici avec un jeu de données fictif appelé
**"data_exemple_ext"**. Il s'agit d'un tableau décrivant plusieurs données
qualitatives, quantitatives et spatiales de l'industrie lithique d'une
collection. 

Pour faciliter notre travail, on va créer un **projet R**. Cela va nous
permettre : 

1.  de rassembler tous les éléments liés à notre séance au sein d'un
    même dossier. 

2.  de simplifier notre code, car nos commandes "path" seront toujours
    précédées par le path du projet 

3.  de partager plus facilement notre travail (toutes les données
    nécessaires au fonctionnement du script seront partagées avec lui)
    ou de le transférer à un autre ordinateur (puisque le path sera
    automatiquement modifié !). 

Pour créer un projet, nous pouvons cliquer sur le bouton en haut à
droite de RStudio. 

> New project...

Puis sélectionnez ou créez le dossier dans lequel vous allez mettre
votre script et vos données. 

Remarquez bien que dans l'onglet "Files" dans le panneau en bas à
droite, nous sommes directement dans le dossier du projet !

**NB:** Personnellement, j'organise tous mes projets de la même façon :
trois sous-dossiers : 

> **"data"** qui contiendra toutes les données brutes utilisées dans ce
> projet 

> **"script"** qui contiendra tous les scripts utilisés 

> **"output"** dans lequel on sauvegardera les résultats de nos codes
> (tableaux, figures etc).

On peut créer ces dossiers manuellement dans Explorer mais il existe
aussi une commande R pour cela ! Elle peut être très utile quand on
souhaite automatiser la sauvegarde de fichiers au sein de dossiers
différents. 

```{r create-files, eval=FALSE, message=FALSE, warning=FALSE, include=FALSE}

dir.create("data") 
dir.create("script") 
dir.create("output")

```

En consultant l'onglet "Files" du panneau en bas à droite, on voit que
nos dossiers ont bien été créés ! 

## 2- Ouvrir un jeu de données

Nous allons commencer par ouvrir le jeu de données "data_exemple_ext" en
utilisant le bouton **"Import dataset"** dans l'onglet "Environnement"
en haut à droite. Ce bouton permet d'écrire automatiquement le code pour
importer un tableau csv. 

Vous pouvez également utiliser une ligne de code toute simple pour
importer votre jeu de données (plus reproductible et très pratique
lorsque l'on utilise les projets R !) 

```{r import-dataset}

jdd <- read.csv("data_exemple_ext.csv", sep = ",", header = T)

```

Vous venez d'ouvrir le tableau dans R ! Il a été stocké dans un objet
que l'on a appelé "jdd". Si vous l'appelez dans la console, il
s'affichera, vous permettant de l'explorer. 

```{r dataset-explore}

jdd

```

Il est également possible, dans l'onglet "Environment" en haut à droite,
d'ouvrir le jeu de données en cliquant sur le petit tableau situé sur la
ligne "jdd". 

Afin de ne pas encombrer la console, il est aussi possible de n'afficher
que les 6 premières lignes du tableau avec `head()`.

```{r dataset-head}

head(jdd)

```

## 3- Explorer un jeu de données

On peut vérifier la classe d'objet de jdd par la commande suivante : 

```{r class}

class(jdd)

```

Un data frame est un type d'objet R correspondant à un tableau. Il
existe plusieurs classes que nous découvrirons au fur et à mesure. 

`class()` est ce qu'on appelle une fonction. C'est une opération qui
sera appliquée à un objet. La fonction class() permet d'afficher la
classe de l'objet auquel on applique cette fonction. Lorsque l'on ne
comprends pas l'objectif d'une fonction ou que l'on a oublié, on peut
demander de l'aide par la fonction `help()` ou plus simplement `?`. 

```{r class2, echo=TRUE, results='hide'}

?class 

help(class) # notez que ces deux commandes ont le même résultat.

```

A présent je souhaite obtenir des informations statistiques générales
sur les différentes dimensions du tableau. On utilise la fonction
`summary()`. 

```{r summary}

summary(jdd)

```

On obtient des informations telles que le min/max/moyenne etc de chaque
variable numérique. 

On peut aussi afficher certaines informations sur les dimensions du
tableau, comme le nombre de colonnes, de lignes. 

```{r explore}

nrow(jdd) # nb de lignes 
ncol(jdd) # nb de colonnes

```

Pour vérifier le type de variable dans un tableau (ce sera important car
certaines fonctions nécessitent un type de variable particulier), on
peut appliquer la fonction `class()` sur chaque variable séparément par
l'opérateur `$`. 

```{r class-var}

class(jdd$type)
class(jdd$longueur_cm)

```

La variable "longueur" est de classe *numérique* tandis que la variable
"type" est de classe *character*. Or, pour traiter des variables
catégorielles avec R il vaut mieux utiliser le format *factor*. Nous
allons donc convertir la variable "type" en factor avec la fonction
`factor()` : 

```{r factor}

jdd$type <- factor(jdd$type) # cette commande signifie au pied de la lettre : dans la colonne "type" du data frame "jdd", je mets la colonne "type" du data frame "jdd" convertie en facteur

```

On vérifie que le code a bien fonctionné avec `class()`. 

```{r check}

class(jdd$type)

```

**NB:** généralement quand on modifie les données primaires, il vaut
toujours mieux créer une nouvelle colonne afin de garder une trace des
données brutes. On aurait pu faire quelque chose comme cela : 

```{r factor2}

jdd$type_fac <- as.factor(jdd$type)

class(jdd$type_fac) # même résultat !

```

Nous pouvons à présent vérifier les différentes valeurs que peut prendre
une variable catégorielle, par la fonction `levels()`. 

```{r levels}

levels(jdd$type)

```

Ces quelques fonctions sont utiles pour explorer les données et se
rendre compte d'erreurs à un stade préliminaire. 

## 4- Créer un graphique simple

### A- Premiers pas 

A présent, essayons de visualiser un graphique de la longueur vs la
largeur des pièces. Dans R base, on utilise la fonction `plot()`. 

```{r plot}

plot(x = jdd$longueur_cm, y = jdd$largeur_cm)

```

Ici, à l'intérieur de la fonction, on a précisé quels arguments étaient
concernés. Un **argument** est un objet que l'on passera à la fonction
pour qu'elle s'éxécute. Les fonctions comme `class()`, `levels()` n'ont
qu'un argument, c'est pourquoi nous n'avons pas eu besoin de le
préciser. De façon générale, les arguments sont rentrés dans l'ordre
chronologique dans lequel ils sont programmés dans la fonction. Voyons
voir cela de plus près. 

```{r plot-help, echo=TRUE, results='hide'}

?plot

```

Dans la fiche d'aide, nous pouvons voir que cette fonction nécessite
deux arguments au minimum : **x** (l'abcisse) et **y** (l'ordonnée). Il
est possible de préciser ou non dans le code quels objets vont dans
quels arguments, mais ce n'est pas nécessaire. Ainsi, la commande
suivante aura le même résultat que précédemment. 

```{r plot2}

plot(jdd$longueur_cm, jdd$largeur_cm)

```

Notez ici l'importance de bien séparer chaque argument par une `,` pour
ne pas créer une erreur. 

### B- Ajouter des titres  

Si la fonction `plot()` nécessite ces deux arguments pour fonctionner,
nous pouvons lui transmettre d'autres arguments annexes permettant
notamment d'améliorer la qualité graphique. Par exemple, modifions un
peu le titre des axes pour que ce soit plus clair. 

```{r plot-axis}

plot(x = jdd$longueur_cm, y = jdd$largeur_cm, 
     xlab = "Longueur (cm)", ylab = "Largeur (cm)") # afin d'éclaircir le code, il est possible de sauter une ligne avant de fermer la parenthèse !

```

Précisons ici que les textes entre guillemets `""` seront
automatiquement considérés comme des objets de type character. Il est
d'ailleurs possible de les définir avant de les inclure dans la fonction
: 

```{r labels}

xlabel <- "Longueur (cm)" 
ylabel <- "Largeur (cm)"

```

et de les afficher : 

```{r labels-show}

xlabel 
ylabel

plot(x = jdd$longueur_cm, y = jdd$largeur_cm, xlab = xlabel, ylab = ylabel)

```

Ajoutons également un titre ! 

```{r title}

title <- "Dimension des objets en silex"

plot(x = jdd$longueur_cm, y = jdd$largeur_cm, 
     xlab = xlabel, ylab = ylabel, 
     main = title)

```

### C- Modifier l'aspect des points (couleur, forme, taille)

Pour aller plus loin dans l'analyse, il est possible de colorer les
points en fonction d'une catégorie. Voyons par exemple ce que cela donne
avec la catégorie "type_fac". 

```{r col}

plot(x = jdd$longueur_cm, y = jdd$largeur_cm, 
     col = jdd$type_fac, 
     xlab = xlabel, ylab = ylabel, main = title)

```

Il est possible de choisir d'autres couleurs que celles-ci, que
personnellement je trouve assez criardes. Il existe tout un univers de
palettes dans R, et vous pouvez explorer cela sur internet. Il y a
notamment de nombreuses librairies qui codent des palettes prédéfinies,
comme `wesanderson`, ou `viridis` (ce sont mes préférées). Dans la suite
de l'exercice, je vais présenter deux façons d'utiliser des couleurs
personnalisées : la méthode "basique" dans R, et l'emploi d'une librairie
déjà codé. 

Pour avoir totalement la main sur vous couleurs, vous pouvez utiliser
les codes héxadécimaux :

![(Source:
<http://www.visibone.com>)](images/hextable-hexadecimal-color-chart.png)

Ou bien les couleurs directement codées dans R...

```{r colors-list}

head(colors()) # on emploie ici head() pour ne pas encombrer la console car il y a 657 couleurs en tout...

```

... dont vous pouvez voir les couleurs en suivant [ce
lien](https://www.datanovia.com/en/fr/blog/liste-geniale-de-657-noms-de-couleur-dans-r/). 

Tout d'abord, avec la fonction `length()`, je vérifie le nombre de
valeurs dans la variable "type". Cela me permet de savoir combien de
couleurs sont nécessaires dans ma palette. 

```{r color}

length(levels(jdd$type_fac)) 

```

Ensuite, avec la fonction `c()`, je créé deux listes de couleurs : l'une
avec des code héxadécimaux, qui débutent toujours avec un `#` et l'une
avec les couleurs pré-codées dans R. Retenez bien cette fonction, `c()`,
qui est essentielle dans R. Elle permet de créer des listes d'objets et
de les combiner.

```{r palettes}

pal1 <- c("#FFCC00", "#CCFF33", "#FF66FF", "#00CC66", "#9933FF") # première liste avec les codes héxadécimaux 

pal2 <- c("khaki4", "indianred1", "grey", "steelblue", "black") # deuxième liste avec des couleurs précodées

pal <- c(pal1, pal2) # Combinaison des deux listes

plot(x = jdd$longueur_cm, y = jdd$largeur_cm, 
     col = pal[as.numeric(jdd$type_fac)], # petite subtilité ici : on indique à la fonction que les couleurs correspondent à des niveaux de "type_fac" en convertissant ces derniers en valeurs numériques avec as.numeric().
     xlab = xlabel, ylab = ylabel, main = title)

```

Vous pouvez également installer des palettes de couleurs codées au sein
de libraries. [Cette
page](https://www.datanovia.com/en/blog/top-r-color-palettes-to-know-for-great-data-visualization/)
recense de nombreuses palettes très jolies par exemple. 

Petite démo avec ma palette préférée personnellement : `viridis` ! 

On installe d'abord la librairie : 

```{r viridis, eval=FALSE, message=FALSE, warning=FALSE, echo=TRUE}

install.packages("viridis")

```
```{r viridis-plot}

library(viridis)

plot(x = jdd$longueur_cm, y = jdd$largeur_cm, 
     col = viridis(10)[as.numeric(jdd$type_fac)], # on indique à viridis() le nombre de couleurs nécessaires
     xlab = xlabel, ylab = ylabel, main = title)

```


On peut également changer la forme des points avec l'argument **"pch"**.
Essayons de faire un graphique avec des formes différentes en fonction
du type de silex. 

**NB:** N'oublions pas de convertir notre colonne silex en facteur ! 

```{r pch}

jdd$silex_fac <- as.factor(jdd$silex)

plot(x = jdd$longueur_cm, y = jdd$largeur_cm, 
     col = viridis(10)[as.numeric(jdd$type_fac)],
     pch = c(16, 17, 18)[as.numeric(jdd$silex_fac)], 
     xlab = xlabel, ylab = ylabel, main = title)

```

Personnellement, je trouve que les points de ce graphe sont beaucoup
trop petits pour être bien visibles. Heureusement, R nous permet de
modifier leur taille au sein de la fonction `plot()`, avec l'argument
**"cex"**.

```{r cex}

plot(x = jdd$longueur_cm, y = jdd$largeur_cm, 
     col = viridis(10)[as.numeric(jdd$type_fac)],
     pch = c(16, 17, 18)[as.numeric(jdd$silex_fac)],
     cex = 1.5,
     xlab = xlabel, ylab = ylabel, main = title)

```

### D- Ajouter des légendes 

Afin de rendre encore plus lisible votre figure, vous pouvez également ajouter une légende avec la fonction `legend()`. Commençons par la légende des types de silex. 

```{r legend1}

plot(x = jdd$longueur_cm, y = jdd$largeur_cm, 
     col = viridis(10)[as.numeric(jdd$type_fac)],
     pch = c(16, 17, 18)[as.numeric(jdd$silex_fac)],
     cex = 1.5,
     xlab = xlabel, ylab = ylabel, main = title)

legend("topleft", # ici préciser la position de la légende
       legend = c("Type A", "Type B", "Type C"), # ici préciser les légendes
       pch = 16:18, # ici préciser les shapes
       cex = 1, # on peut ici ajuster la taille de la légende
       horiz = TRUE) # ici, on précise si l'on souhaite que la légende soit horizontale ou verticale
```

Il est possible d'ajouter plusieurs légendes sur une même figure ! Il suffit de la mettre en suivant.

```{r legend2, echo=T}
plot(x = jdd$longueur_cm, y = jdd$largeur_cm, 
     col = viridis(10)[as.numeric(jdd$type_fac)],
     pch = c(16, 17, 18)[as.numeric(jdd$silex_fac)],
     cex = 1.5,
     xlab = xlabel, ylab = ylabel, main = title)

legend("topleft", 
       legend = c("Type A", "Type B", "Type C"), 
       pch = 16:18, 
       cex = 1, 
       horiz = TRUE)

# Rajoutons la légende pour les types de pièces 
legend("bottomright",
       legend = levels(jdd$type_fac),
       fill = viridis(10), # l'argument "fill" permet de préciser les couleurs sous la forme de rectangles de légende 
       cex = 0.75) 
```

## 5- Enregistrer une figure

Enfin, dernière étape de notre TD : enregistrer notre figure ! 

Il existe plusieurs solutions : 

La première est de cliquer sur le bouton **"export"** dans l'onglet
"plot". Vous pouvez alors choisir le dossier dans lequel sauvegarder la
figure, dont vous pouvez modifier les dimensions manuellement. 

Toutefois, il est parfois utile de sauvegarder directement la figure
avec une ligne de code, notamment dans le but de réaliser plusieurs
figures similaires de la même taille exactement ! Cette façon de faire
est plus reproductible et ne complique par le code outre mesure. 

Enregistrons notre figure en format png. Il faut tout d'abord créer un
fichier tiff vide de la taille voulue : 

```{r tiff, eval=FALSE, echo=TRUE}

tiff("Figure1.tiff", # ici on écrit le chemin vers la figure 
    width = 450, height = 450) # et là les dimensions de la figure en cm.

```

On écrit la figure dans le tiff... 

```{r tiff-plot}

plot(x = jdd$longueur_cm, y = jdd$largeur_cm, 
     col = pal[as.numeric(jdd$type_fac)],
     pch = c(16, 17, 18)[as.numeric(jdd$silex_fac)],
     cex = 1.5,
     xlab = xlabel, ylab = ylabel, main = title)

legend("topleft", 
       legend = c("Type A", "Type B", "Type C"), 
       pch = 16:18, 
       cex = 1, 
       horiz = TRUE)

legend("bottomright",
       legend = levels(jdd$type_fac),
       fill = pal, 
       cex = 0.75) 

```

... et on clôture l'écriture de la figure dans le pdf. 

```{r pdf-save, eval=FALSE, echo=TRUE}

dev.off()

```

FELICITATIONS ! Vous avez fait vos premiers pas sur R !! 

## BONUS

### A- Petit challenge : arriverez-vous à obtenir les informations et figures suivantes ?

Je vous propose dans cette section de jouer avec un jeu de données
comportant plusieurs informations qualitatives et quantitatives sur des
pointes de flèches de la période Archaïque, récoltées à Fort Hood au
Texas au cours de prospections de surface. Ce jeu de données est
disponible au sein du package `archdata`, qui regroupe plusieurs jeux de
données archéologiques. 

**1. Préparez-vous à réaliser les exercices :** 

-   1.1. Commencez tout d'abord par installer le package `archdata`. 

-   1.2. Maintenant, ouvrez la librarie `archdata` et le jeu de données
    `DartPoints`.  

**2. Familiarisez-vous avec le jeu de données :** 

-   2.1. Combien y a-t-il de variables (colonnes) et d'enregistrements
    (lignes) dans le jeu de données ? 

-   2.2. Lister les types de variables du jeu de données : combien y en
    a-t-il ? 

-   2.3. Pour chaque type de pointe, récupérer la médiane et l'écart
    type pour la longueur/largeur/épaisseur.  

**3. Créez des graphique :** 

-   3.1. Visualiser le ratio largeur de la base/largeur maximale des
    pointes sous la forme d'un nuage de points. Utiliser un code couleur
    pour la forme de la base (*"Base.Sh"*) et un code de forme pour le
    type de pointe (*"Name"*). Soignez les titres des axes et la
    légende, puis sauvegardez le graphique. 

-   3.2. Créer des boites à moustaches en utilisant la fonction
    `boxplot()` pour visualiser les statistiques de bases de la
    longueur/largeur/épaisseur en fonction du type de pointe. Soignez
    les titres des axes et la légende, puis sauvegardez les graphiques. 

-   3.3. Créez un histogramme en utilisant la fonction `hist()` afin de visualiser la distribution des trois variables de largeur
    mesurées sur les pointes (*"Width"*, *"B.Width"*, *"J.Width"*). Renseignez-vous sur l'argument "add" pour superposer des figures sur une même figure...
    Prenez soin de modifier les couleurs de chaque variable pour que
    l'histogramme soit lisible. Soignez les titres des axes et la
    légende, puis sauvegardez le graphique. 

**NB:** vous touverez sur [ce site](https://r-graph-gallery.com/)
quantité d'exemple des graphes avec base R ou des paquets plus
spécialisés. 

### B- Données archéologiques spatialisées : l'application RShiny `archeoviz`

`archeoViz` est une application RShiny pour l'**exploration** visuelle
et statistique ainsi que la **communication web** de données
archéologiques spatialisées. Elle offre des **visualisations** (coupes
et cartes de restes archéologiques, chronologie des fouilles) qui
peuvent être exportées au format svg et html. Elle permet de faire des
**statistiques spatiales simples** (enveloppes convexes, surfaces de
régression, estimations de densité 2D) et permet d'exporter des données
vers d'autres applications en ligne pour l'utilisation de méthodes plus
complexes. 

`archeoViz` peut être utilisée **hors-ligne** localement ou **en ligne**
sur un serveur (par exemple, [l'instance générique sur le serveur
huma-num](https://analytics.huma-num.fr/archeoviz/fr/). L'interface de
l'application est disponible en anglais, français, allemand, italien,
portugais, romain et espagnol. 

L'application RShiny `archeoViz` fait partie d'un écosystème plus large,
avec notamment l'existence d'un portail - **le portail archeoViz** -
recensant différentes instances de l'application avec des jeux de
données archéologiques spatialisées spécifiques. Vous pouvez explorer ce
portail ainsi que les jeux de données qu'ils recensent
[ici](https://analytics.huma-num.fr/archeoviz/home). Voici par exemple l'instance reliée au jeu de donnée présenté plus tôt, concernant le site du [Flageolet I à Bézénac (France)](https://analytics.huma-num.fr/archeoviz/le-flageolet).\  

Si vous souhaitez
contribuer à cette démarche et mettre en valeur votre jeu de données,
n'hésitez pas à contacter [**l'équipe de
maintenance**](archeoviz-maintainers@services.cnrs.fr) pour vous aider à
publier votre propre instance ! 

Dans cette section, je vous propose d'explorer le jeu de données fictif
de notre TP avec `archeoViz`. Pour cela, commencez par installer
l'application : 

```{r archeoviz, eval=FALSE, message=FALSE, warning=FALSE, echo=TRUE}

install.packages("archeoViz")

```

`archeoViz` demande un format spécifique de jeu de données. Celui-ci est
simple et comporte quelques champs obligatoires. Nous allons dans les
lignes suivantes recréer un tableau avec la syntaxe `archeoViz` à partir
de notre jeu de données initial "jdd".  

```{r archeoviz-data}

library(archeoViz)

jdd.archeoviz <- data.frame( 
    # les colonnes suivantes sont obligatoires 
  id = jdd$numero, ## identifiant unique de l'objet 
  xmin = jdd$x_cm, ## coordonnée de l'objet en axe X (en cm)
  ymin = jdd$y_cm, ## coordonnée de l'objet en axe Y (en cm)
  zmin = -jdd$z_cm, ## coordonnée de l'objet en axe Z (valeur de profondeur en cm)
  layer = jdd$couche, ## identifiant de la couche de l'objet
  object_type = jdd$type, ## catégorie de l'objet
    # les colonnes suivantes ne sont pas obligatoires 
  year = jdd$année, ## année de fouille de l'objet
  object_silex = jdd$silex) ## variable additionnelle décrivant l'objet

```

Nous pouvons également créer un tableau pour afficher les remontages
dans l'application. 

```{r archeoviz-rem}

# chaque ligne du tableau "remontages" doit être composé de deux colonnes avec les id de deux objets reliés par une relation. 

jdd.rem <- data.frame(id1 = c(3, 9, 17),
                      id2 = c(8, 31, 32))

```

Ensuite, nous pouvons utiliser la ligne de code suivante pour créer une
instance de l'application. 

```{r archeoviz-app, echo=TRUE, results="hide", message=FALSE, warning=FALSE}

archeoViz(objects.df = jdd.archeoviz, 
          square.size= 100, 
          unit = 'cm', 
          lang = 'fr', 
          set.theme = 'simplex', 
          run.plots = TRUE, 
          html.export = TRUE, 
          home.text = ' ', 
          class.variable = 'object_type', 
          default.group = 'by.layer', 
          location.mode = 'exact', 
          map.density = '', 
          plot3d.hulls = TRUE,
          rotation = 0)

```

Pour encore plus de facilité, vous pouvez entrer les données directement dans l'[instance web générique](https://analytics.huma-num.fr/archeoviz/fr/), dans l'onglet "Données" !


## Pour aller plus loin...

N'hésitez pas à explorer les nombreux blogs, forums et pages R
disponibles sur internet ! La communauté R est très active : en général,
si vous ne savez pas comment faire une opération ou si vous obtenez une
erreur que vous ne comprenez pas, cherchez sur Google ! Quelqu'un a très
certainement déjà eu le même problème que vous et a proposé une solution
sur un forum. 
