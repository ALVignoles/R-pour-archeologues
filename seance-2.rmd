---
title: "Séance 2 : Analyser et visualiser un jeu de données semi-quantitatif"
output: bookdown::html_document2
---

# - Introduction
Nous avons vu à la séance précédente comment parcourir un jeu de données et faire un graphique simple avec le language R de base.  
Au cours de cette séance nous utiliserons les extensions de la bibliothèque **tidyverse**. Ce terme est une contraction de *tidy* (qu’on pourrait traduire par “bien rangé”) et de *universe*. Il s’agit d’une collection d’extensions conçues à partir d'une philosophie commune. Elles abordent un très grand nombre d’opérations courantes dans R (la liste n’est pas exhaustive):\
- l'import/export de données\
- la manipulation des tableaux de données\
- la manipulation de variables\
- la visualisation\
- l'extraction de données du web\
- la programmation\

L'un des objectifs de ces extensions est de fournir des fonctions avec une syntaxe cohérente, qui fonctionnent bien ensemble, et qui retournent des résultats prévisibles. Elles sont en grande partie issues du travail d’Hadley Wickham.  
Téléchargeons et chargons l'ensemble des bibliothèques du **tidyverse** avec les commandes suivantes
```{r tidyverse, echo=T}
#install.packages("tidyverse")
#library(tidyverse)
```

# - Importer un jeu de données
Dans l'idéal il convient d'importer un tableau depuis excel (ou autre programme) à partir de CSVs (comma-separated-values), qui est un format simple, non-propriétaire (qui ne nécessite pas d'être lu par un logiciel particulier (et la plupart du temps payant), en texte simple ("plain-text"), qui permet à la fois d'être lu par l'humain, traité par la machine, et convient au stockage de données organisées en colonnes/lignes).\

Point important: éviter les espaces ( ` ` ) et les parenthèses ( `(` ou `)` ) dans les cellules des tableaux, car R comble automatiquement ces blancs avec des signes.

Dans R on peut charger et lire ce jeu de données avec la fonction de base `read.csv()`. 
```{r import csv, echo=T}
jdd <- read.csv("data/data_exemple.csv") 
# attention à bien vérifier quel séparateur est utilisé : "," ";" ou "tab"
# par défaut read.csv() va estimer que le séparateur est un ",".
# si ce n'est pas le cas préciser avec sep=""
```

Des données dans d'autres format peuvent être lu avec la fonction `read.table()`.
```{r import read.table, echo=T}
jdd <- read.table("data/data_exemple.txt", sep=",", header = TRUE)
# attention à bien vérifier quel séparateur est utilisé : "," ";" ou "tab"
# par défaut read.table() va estimer que le séparateur est une tabulation.
# si ce n'est pas le cas préciser avec sep=""

# avec read.table() préciser également header = TRUE pour indiquer que la première ligne
# correspond au nom des colonnes
```

Pour ouvrir des fichiers au format Microsoft Excel on peut utiliser les fonctions de la bibliothèque **readxl**:\  `read_excel()`,`read_xls()`, `read_xlsx()`.
```{r import read_xlsx, echo=T}
#install.packages("readxl")
library(readxl)
jdd <- read_xlsx("data/data_exemple.xlsx")
```
Des tables enregistrées au format OpenDocument peuvent être lu grace à la fonction `readODS()`.


# - Manipuler un jeu de données
https://gitlab.com/linogaliana/bigr/-/blob/master/04-datatable.Rmd

Tout d'abord voici quelques éléments de code de base dans le language R :\
- `<-` est un "opérateurs d’assignation", et s'utilise de telle manière que l'objet nommé à la gauche de ce signe correspond au résultat (*output*) du code à sa droite. C'est dans ce sens que l'on vient de l'utiliser plus haut avec par exemple `jdd <- read.csv("data/data_exemple.csv")`\
- `&` signifie ET (AND) dans 
- les opérateurs de base de la logique booléenne (logique à deux états, 0 et 1, qui permet d'analyser des décisions et de trier des jeux de données) sont "ET" `&`, "OU" `|`, et "NON" `!`\
- les contenus de classe "character" (texte ou dates) doivent être entrés en utilisant les guillements `""`.\
- les contenus de classe "numeric" ne sont pas entre guillemets.
- comme dans les formules d'excel, un ensemble de valeurs peut être défini en formant un vecteur en utilisant les deux points `:` au sein de la fonction `c()`.\
- les opérateurs logiques les plus communs:\
`+` ajouter\
`-` soustraire\
`*` multiplier\
`/` diviser\
`>` et `<` pour plus grand/plus petit que\
`>=` et `<=` pour plus grand ou égal à / plus petit ou égal à\
`!=` pas égal à\
`==` voir le/les objet(s) égal(aux) à... souvent utiliser pour sélectionner/filter des données\
`=` fait qu'un objet est égal à une valeur donnée. fonctionne comme `<-`, mais à l'intérieur d'une fonction.

Il existe des fonctions très utiles dans le language R de base que l'on peut également passer avec les fonctions des bibliothèques **data.table()** et **dplyr()** du tydiverse.\

## Sélectionner/filtrer le contenu de cellules particulières (dans la console)
### Avec R de base
```{r filter base R, echo=T}
jdd[3:5, ] #les lignes 3 à 5
jdd[ , 1:4] #les colonnes 1 à 4 (ne montre que les 10 premières lignes)
jdd[3, 1:4] #les cellules en 3e ligne, des colonnes 1 à 4
jdd[jdd$type == "burin", ] #les lignes pour lesquelles le contenu de la colonne "type" correspond exactement à "burin"
jdd[grep("burin", jdd$type), ] #toutes les lignes qui contiennent le mot "burin" dans la colonne "type"
subset(jdd, as.numeric(longueur_cm) < 3) #toutes les lignes qui des valeurs de longueur_cm inférieures à 3

```

### Avec `data.table()`
```{r data.table, echo=T}
#install.packages("data.table")
library(data.table)
```
```{r filter data.table, echo=T}
jdd[jdd$type %like% "burin", ] # toutes les lignes qui contiennent "burin" dans la colonne "type"
#jdd[jdd$type %like% c("burin","lam"), ] # toutes les lignes qui contiennent "burin" ou "lam" dans la colonne "type"
#jdd[jdd$longueur_cm < 5]  # toutes les lignes qui contiennent "burin" dans la colonne "type"

```

### Avec `dplyr()` (bibliothèque du tidyverse)
```{r select dplyr, echo=T}

```

dplyr and data.table for splitting the data up by groups, applying some common or custom functions, and combining the output back into a convenient form (ie. typical aggregation, splitting and summarising operations). Both packages are fast on very large datasets.

