---
title: "Séance 2 : Analyser et visualiser un jeu de données semi-quantitatif"
output: bookdown::html_document2
---

# - Introduction
Nous avons vu à la séance précédente comment parcourir un jeu de données et faire un graphique simple avec le language R de base.  
Au cours de cette séance nous utiliserons les extensions de la bibliothèque **tidyverse**. Ce terme est une contraction de *tidy* (qu’on pourrait traduire par “bien rangé”) et de *universe*. Il s’agit d’une collection d’extensions conçues à partir d'une philosophie commune. Elles abordent un très grand nombre d’opérations courantes dans R (la liste n’est pas exhaustive):\
- l'import/export de données\
- la manipulation des tableaux de données\
- la manipulation de variables\
- la visualisation\
- l'extraction de données du web\
- la programmation\

L'un des objectifs de ces extensions est de fournir des fonctions avec une syntaxe cohérente, qui fonctionnent bien ensemble, et qui retournent des résultats prévisibles. Elles sont en grande partie issues du travail d’Hadley Wickham.  
Téléchargeons et chargons l'ensemble des bibliothèques du **tidyverse** avec les commandes suivantes
```{r tidyverse, echo=T}
#install.packages("tidyverse")
#library(tidyverse)
```

# - Importer un jeu de données
Dans l'idéal il convient d'importer un tableau depuis excel (ou autre programme) à partir de CSVs (comma-separated-values), qui est un format simple, non-propriétaire (qui ne nécessite pas d'être lu par un logiciel particulier (et la plupart du temps payant), en texte simple ("plain-text"), qui permet à la fois d'être lu par l'humain, traité par la machine, et convient au stockage de données organisées en colonnes/lignes).\

Point important: éviter les espaces ( ` ` ) et les parenthèses ( `(` ou `)` ) dans les cellules des tableaux, car R comble automatiquement ces blancs avec des signes.

Dans R on peut charger et lire ce jeu de données avec la fonction de base `read.csv()`. 
```{r import csv, echo=T}
jdd <- read.csv("data/data_exemple.csv") 
# attention à bien vérifier quel séparateur est utilisé : "," ";" ou "tab"
# par défaut read.csv() va estimer que le séparateur est un ",".
# si ce n'est pas le cas préciser avec sep=""
```

Des données dans d'autres format peuvent être lu avec la fonction `read.table()`.
```{r import read.table, echo=T}
jdd <- read.table("data/data_exemple.txt", sep=",", header = TRUE)
# attention à bien vérifier quel séparateur est utilisé : "," ";" ou "tab"
# par défaut read.table() va estimer que le séparateur est une tabulation.
# si ce n'est pas le cas préciser avec sep=""

# avec read.table() préciser également header = TRUE pour indiquer que la première ligne
# correspond au nom des colonnes
```

Pour ouvrir des fichiers au format Microsoft Excel on peut utiliser les fonctions de la bibliothèque **readxl**:\  `read_excel()`,`read_xls()`, `read_xlsx()`.
```{r import read_xlsx, echo=T}
#install.packages("readxl")
library(readxl)
jdd <- read_xlsx("data/data_exemple.xlsx")
```
Des tables enregistrées au format OpenDocument peuvent être lu grace à la fonction `readODS()`.


# - Manipuler un jeu de données
https://gitlab.com/linogaliana/bigr/-/blob/master/04-datatable.Rmd

Tout d'abord voici quelques éléments de code de base dans le language R :\
- `<-` est un "opérateurs d’assignation", et s'utilise de telle manière que l'objet nommé à la gauche de ce signe correspond au résultat (*output*) du code à sa droite. C'est dans ce sens que l'on vient de l'utiliser plus haut avec par exemple `jdd <- read.csv("data/data_exemple.csv")`\
- `&` signifie ET (AND) dans 
- les opérateurs de base de la logique booléenne (logique à deux états, 0 et 1, qui permet d'analyser des décisions et de trier des jeux de données) sont "ET" `&`, "OU" `|`, et "NON" `!`\
- les contenus de classe "character" (texte ou dates) doivent être entrés en utilisant les guillements `""`.\
- les contenus de classe "numeric" ne sont pas entre guillemets.
- comme dans les formules d'excel, un ensemble de valeurs peut être défini en utilisant les deux points `:` au sein 

As in a spreadsheet, you can specify a range of values with a colon, for example: c(1:10) creates a list of integers (whole numbers) from one to ten.
Some common operators:

+ - add, subtract.
* / multiply, divide.
> < greater than, less than.
>= <= greater than or equal to, less than or equal to.
!= not equal to.
Equals signs can be a little confusing, but see how they are used in the code we use today:

== test whether an object is equal to a value. This is often used when filtering data, as we will see.
= make an object equal to a value; works like <-, but used within the brackets of a function.

Il existe des fonctions très utiles dans le language R de base que l'on peut également passer avec les fonctions des bibliothèques **data.table()** et **dplyr()** du tydiverse.\

## Sélectionner/voir le contenu de cellules particulières (dans la console)
### Avec `data.table()`

```{r data.table, echo=T}
#install.packages("data.table")
library(data.table)
```
```{r select data.table, echo=T}
jdd[3:5,] #sélectionner les lignes 3 à 5
jdd[,1:4] #sélectionner les colonnes 1 à 4 (ne montre que les 10 premières lignes)
jdd[3,1:4] #sélectionner les cellules en 3e ligne, des colonnes 1 à 4
jdd[jdd$type == "burin", ]  #sélectionner toutes les lignes avec le contenu "burin" dans la colonne "type"
#jdd[jdd$type %like% "burin", ]  #sélectionner toutes les lignes qui contiennent "burin" dans la colonne "type"
#jdd[type %like% "burin"]

```

### Avec `dplyr()` (bibliothèque du tidyverse)
```{r select dplyr, echo=T}

```

dplyr and data.table for splitting the data up by groups, applying some common or custom functions, and combining the output back into a convenient form (ie. typical aggregation, splitting and summarising operations). Both packages are fast on very large datasets.

