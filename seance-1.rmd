---
title: "Séance 1 : Se familiariser avec R"
output: bookdown::html_document2
---

```{r setup, include=F, echo=F}
library(here)
library(tidyverse)
```

# - Introduction

Dans cette introduction, nous allons d?couvrir les bases du langage de programmation R.\
Tout d'abord, tout le texte pr?c?d? par le signe \# est ce qu'on appelle un commentaire.

```{r comment, echo=T}
# commentaire
```

Ce sont des lignes qui ne seront pas ex?cut?es par le code et qui nous permettrons de d?crire les ?tapes du script. Bien commenter son code est tr?s important car cela nous permet de le comprendre facilement m?me apr?s des mois et des ann?es sans y avoir travaill? (en th?orie !). Cela nous permet aussi de le partager avec d'autres personnes, pour qu'elles comprennent tout de suite notre d?marche.

Nous allons travailler ici avec un jeu de donn?es fictif appel? `Data_exemple`.\
Il s'agit d'un tableau d?crivant plusieurs donn?es qualitatives, quantitatives et spatiales de l'industrie lithique d'une collection.

Les jeux de donn?es utilis?s dans le cadre de ce workshop sont stock?s dans le dossier `data` du r?pertoire clon? ("t?l?charg?") depuis github `R-pour-archeologues`. Nous avons ouvert le fichier `R-pour-archeologues.Rproj` afin de travailler au sein d'un environnement commun ? tou-te-s, ce qui nous permet d'avoir un m?me dossier actif au d?marrage de R. Cela sera utile pour charger les jeux de donn?es et sauvegarder les r?sultats de nos productions dans cet espace.

# - Ouvrir un jeu de donn?es

Il existe deux mani?res d'ouvrir un jeu de donn?es:\
- en utilisant le pointer-cliquer\
- en utilisant du code

## - M?thode pointer-cliquer

Nous allons commencer par ouvrir le jeu de donn?es `Data_exemple` en utilisant le bouton `Import dataset` dans l'onglet `Environnement` en haut ? droite:\
1- Choisir le fichier dans le r?pertoire avec le bouton `browse`:\
<code>.../R-pour-archeologues/data/Data_exemple.xlsx</code> 2- Dans cette m?me fen?tre dans la section `import options` il est possible de sp?cifier le nom du jeu de donn?es qui sera stock? dans R: appelez le "jdd".\
Cette proc?dure permet d'importer un tableau excel.

## - M?thode par le code

Pr?f?rez l'utilisation du code afin de rendre l'ensemble de la proc?dure reproductible.\
Pour cela on utilisera la fonction `read.csv` ou `read_excel`.

```{r dataset, echo=T}
jdd <- read.csv("data/data_exemple.csv")

# on peut pr?ciser :
jdd <- read.csv(            # ouverture de la fonction read.csv()
  "data/data_exemple.csv",  # le chemin du fichier
  header = TRUE,            # si la premi?re ligne contient le titre des col 
  sep=",",                  # le s?parateur (, ou ; ou autre, c'est selon..)
  )                         # fermeture de la fonction read.csv()

# ou si vous travaillez ? partir d'une feuille excel: 
# jdd <- read_excel("data/Data_exemple.xlsx")
```

# - Explorer un jeu de donn?es

Vous venez d'ouvrir le tableau dans R et il a ?t? stock? dans un objet que l'on a appel? `jdd`.

Pour explorer ce jeu de donn?es il est possible d'utiliser le pointer-cliquer en cliquant sur la ligne `jdd`, situ?e la section `Data` du panneau en haut ? droite (onglet `Environment`).\
Mais pr?f?rez l? aussi le code: soit avec la commande `view(jdd)` (m?me r?sultat que pr?c?demment avec le pointer-cliquer)

```{r dataset view, echo=T}
view(jdd)
```

ou simplement en utilisant la commande `jdd` (nom du jeu de donn?es) pour afficher le contenu du tableau dans la console

```{r dataset console, echo=T}
jdd
```

Afin de ne pas encombrer la console, il est aussi possible de n'afficher que les 6 premi?res lignes du tableau avec la commande `head()`

```{r dataset head, echo=T}
head(jdd)
```

# - Explorer un jeu de donn?es

Un data frame est un type d'objet R correspondant ? un tableau. Il existe plusieurs classes que nous d?couvrirons au fur et ? mesure.\
On peut v?rifier la classe d'objet de `jdd` avec la commande `class(jdd)`. `class()` est **une fonction**. C'est une op?ration qui sera appliqu?e ? un objet. La fonction `class()` permet d'afficher la classe de l'objet auquel on applique cette fonction.

```{r class, echo=T}
class(jdd)
```

Lorsque l'on ne comprends pas l'objectif d'une fonction ou que l'on a oubli?, on peut demander de l'aide avec la fonction `help()` ou plus simplement ? `?class`.

```{r help, echo=T}
?class
help(class) # notez que ces deux commandes ont le m?me r?sultat.
```

Si l'on souhaite obtenir des informations statistiques g?n?rales sur les diff?rentes dimensions du tableau. On utilise la fonction `summary()` pour obtenir des informations basiques telles que le min/max/moyenne etc de chaque variable de classe num?rique.

```{r summary, echo=T}
summary(jdd)
```

On peut aussi afficher certaines informations sur les dimensions du tableau, comme le nombre de colonnes et de lignes par exemple

```{r nrowcol, echo=T}
nrow(jdd) # nb de lignes
ncol(jdd) # nb de colonnes 
```

Pour v?rifier le type de variable dans un tableau (ce sera important car certaines fonctions qui n?cessitent un type sp?cifique de variable), on peut appliquer la fonction `class()` sur chaque variable que l'on associe au jeu de donn? avec l'op?rateur `$`

```{r classcol, echo=T}
class(jdd$type)
class(jdd$longueur)
```

La variable `longueur` est de classe num?rique tandis que la variable `type` est de classe `character`. Or, pour que R traite des variables cat?gorielles avec R il faut utiliser le format `factor`. Nous allons donc convertir la variable `type` en un facteur avec la fonction `factor()`.

```{r makefactor, echo=T}
jdd$type <- factor(jdd$type) # cette commande signifie au pied de la lettre : 
                             # dans la colonne "type" du data frame "jdd", je  
                             # mets la colonne "type" du data frame "jdd" 
                             # au format "facteur"
```

On v?rifie que le code a bien fonctionn? avec class()

```{r classcol2, echo=T}
class(jdd$type)
```

Lorsque l'on modifie les donn?es primaires, il est parfois pr?f?rable de cr?er une nouvelle colonne afin de garder une trace des donn?es brutes

```{r makefactor2, echo=T}
jdd$type_fac <- as.factor(jdd$type)

class(jdd$type_fac) # notez: m?me r?sultat que pr?c?demment
```

Nous pouvons ? pr?sent v?rifier les diff?rentes valeurs que peut prendre une variable cat?gorielle, par la fonction `levels()`

```{r levels, echo=T}
levels(jdd$type)
```

Ces quelques fonctions sont utiles pour explorer les donn?es et se rendre compte d'erreurs ? un stade pr?liminaire.

# - Cr?er un graphique simple

A pr?sent, essayons de visualiser un graphique de la longueur vs la largeur des pi?ces.\
Dans le language R de base, on utilise la fonction `plot()`

```{r plot1, echo=T}
plot(x = jdd$longueur, y = jdd$largeur)
```

Ici, ? l'int?rieur de la fonction, on a pr?cis? quels arguments ?taient concern?s: x et y. Les fonctions comme `class()`, `levels()` n'ont qu'un argument, c'est pourquoi nous n'avons pas eu besoin de le pr?ciser.

Un argument est un objet que l'on passera ? la fonction pour qu'elle s'ex?cute. De façon g?n?rale, les arguments sont rentr?s dans l'ordre chronologique dans lequel ils sont programm?s dans la fonction. Voyons voir cela de plus pr?s.

```{r plothelp, echo=T}
?plot
```

Dans la fiche d'aide, nous pouvons voir que cette fonction n?cessite deux arguments au minimum :\
`x` (abscisse) et `y` (ordonn?e).\
Il est possible de pr?ciser ou non dans le code quels objets vont dans quels arguments, mais ce n'est pas n?cessaire si l'on respecte l'ordre logique avec `x` d'abord et `y` ensuite.\
Ainsi, la commande suivante aura le m?me r?sultat que pr?c?demment

```{r plot2, echo=T}
plot(jdd$longueur, jdd$largeur)
```

Notez ici l'importance de bien s?parer chaque argument par une virgule `,`. Sans cela R il n'est pas possible de passer la commande.

Si la fonction `plot()` n?cessite ces deux arguments pour fonctionner, nous pouvons lui transmettre d'autres arguments annexes permettant d'am?liorer la qualit? graphique. Par exemple, modifions un peu le titre des axes pour que ce soit plus clair:

```{r}
plot(
  x = jdd$longueur,             # il est possible de sauter une ligne 
  y = jdd$largeur,              # apr?s chaque virgule ou parenth?se
     xlab = "Longueur (cm)",    # pour faciliter la lecture du code
     ylab = "Largeur (cm)"      # avant de fermer la parenth?se
     )
```

Pr?cisons ici que les textes entre guillemets ("" ou '') seront automatiquement consid?r?s comme des objets de type caract?re. Il est d'ailleurs possible de les d?finir avant de les inclure dans la fonction:

```{r plot3, echo=T}
xlabel <- "Longueur (cm)"
ylabel <- "Largeur (cm)"
plot(x = jdd$longueur, y = jdd$largeur,
     xlab = xlabel, ylab = ylabel)

# Ajoutons l'objet du titre avant de l'ins?rer dans le plot
title <- "Dimension des objets en silex"
plot(x = jdd$longueur, y = jdd$largeur,
     xlab = xlabel, ylab = ylabel, 
     main = title)
```

Pour aller plus loin, il est possible de colorer les points en fonction d'une cat?gorie. Essayons avec la cat?gorie `type_fac`

```{r plot4, echo=T}
plot(x = jdd$longueur, y = jdd$largeur,
     col = jdd$type_fac, 
     xlab = xlabel, ylab = ylabel,
     main = title)
```

On peut ?galement changer la forme des points avec l'argument `pch`. Essayons de faire un graphique avec des formes diff?rentes en fonction du type de silex. NB : N'oublions pas de convertir notre colonne silex en facteur !

```{r plot5, echo=T}
jdd$silex_fac <- as.factor(jdd$silex)

plot(x = jdd$longueur, y = jdd$largeur,
     col = jdd$type_fac, 
     pch = c(16, 17, 18)[as.numeric(jdd$silex_fac)], # ici, on assigne les formes
                                                     # 16, 17 et 18 aux levels  
     xlab = xlabel, ylab = ylabel, 
     main = title)
```

Les points de ce graphe sont trop petits pour ?tre bien visibles. Mais il est possible de modifier leur taille au sein de la fonction `plot()`.

```{r plot6, echo=T}
plot(x = jdd$longueur, y = jdd$largeur,
     col = jdd$type_fac, 
     pch = c(16, 17, 18)[as.numeric(jdd$silex_fac)],  
     cex = 1.5,
     xlab = xlabel, ylab = ylabel, 
     main = title)
```

# - Enregistrer un graphique

Il existe plusieurs moyens pour enregistrer une figure:\
- Le premier est de cliquer sur le bouton `Export` dans l'onglet `Plots`. Vous pouvez alors choisir le dossier dans lequel sauvegarder la figure, dont vous pouvez modifier les dimensions manuellement.\
- Toutefois, il est parfois utile de sauvegarder directement la figure avec une ligne de code, notamment dans le but de r?aliser plusieurs figures similaires de la m?me taille exactement ! Utiliser la fonction `pdf()` est plus reproductible et ne complique par le code outre mesure.

Enregistrons notre figure au format pdf de cette mani?re:

```{r plot6save, eval = F, echo=T}
#Il faut tout d'abord cr?er un fichier pdf vide de la taille voulue
pdf("figures/Figure1.pdf",        # ici on ?crit le chemin vers la figure
     width = 4.5, height = 4.5)   # et ici les dimensions de la figure en cm. 

### On ?crit la figure dans le pdf
plot(x = jdd$longueur, y = jdd$largeur,
     col = jdd$type_fac, 
     pch = c(16, 17, 18)[as.numeric(jdd$silex_fac)], 
     cex = 1.5,
     xlab = xlabel, ylab = ylabel, 
     main = title)

### et on cloture l'?criture de la figure dans le pdf

dev.off()
```

**FELICITATIONS ! Vous avez fait vos premiers pas sur R !!**
